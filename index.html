<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>B935016 고영광 – Portfolio</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 UMD + Babel (브라우저에서 JSX 변환용) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html, body, #root { height: 100%; }
    body { background: #000; margin: 0; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- JSX를 브라우저에서 바로 변환해서 실행 -->
  <script type="text/babel">
    // import React from "react";  // ❌ 불필요
    // 전역 React 사용 (UMD)
    const React = window.React;

    /**
     * Big Dipper (북두칠성) – Interactive Portfolio + PPT-Style Editor
     * - 편집 모드: 각 노드(7개)의 제목/설명/링크와 슬라이드(deck)를 GUI로 편집 → localStorage 저장
     * - 슬라이드 유형: image, imageText(좌/우/오버레이), textOnly
     * - 노드 클릭: deck이 있으면 모달 슬라이드 쇼, 없으면 링크(새 탭)
     * - JSON 내보내기/가져오기 지원
     */

    // ───────────────────────────────────────────────────────────────────────────────
    // 기본 작품 정보 (좌→우, 7개)
    const defaultWorks = [
      { id: 1, key: "Dubhe",  label: "프로필", desc: "소개 / 연락처 / 링크", href: "/profile/", deck: [] },
      { id: 2, key: "Merak",  label: "2-2",   desc: "프로젝트 2-2",       href: "/work/2-2/", deck: [] },
      { id: 3, key: "Phecda", label: "3-1",   desc: "프로젝트 3-1",       href: "/work/3-1/", deck: [] },
      { id: 4, key: "Megrez", label: "3-2",   desc: "프로젝트 3-2",       href: "/work/3-2/", deck: [] },
      { id: 5, key: "Alioth", label: "4-1",   desc: "프로젝트 4-1",       href: "/work/4-1/", deck: [] },
      { id: 6, key: "Mizar",  label: "4-2",   desc: "프로젝트 4-2",       href: "/work/4-2/", deck: [] },
      { id: 7, key: "Alkaid", label: "5-1",   desc: "프로젝트 5-1",       href: "/work/5-1/", deck: [] },
    ];

    // 북두칠성 좌표 (뷰박스 0~100)
    const starLayout = [
      { id: 1, x: 10, y: 20 },
      { id: 2, x: 16, y: 50 },
      { id: 3, x: 36, y: 60 },
      { id: 4, x: 47, y: 40 },
      { id: 5, x: 62, y: 34 },
      { id: 6, x: 73, y: 30 },
      { id: 7, x: 86, y: 36 },
    ];

    function mergeWorksWithLayout(works) {
      return starLayout.map((pos, i) => ({ ...pos, ...(works[i] || {}), index: i }));
    }

    // ───────────────────────────────────────────────────────────────────────────────
    function BigDipperPortfolio({
      works = defaultWorks,
      title = "B935016 고영광",
      backgroundMode = "image", // 'image' | 'procedural'
      backgroundImageUrl = "https://images.unsplash.com/photo-1523986371872-9d3ba2e2b1b9?q=80&w=1600&auto=format&fit=crop",
      showOverlayStars = false,
      canvasAspect = "16/9",
      dipperScaleX = 0.85,   // 가로 압축
      dipperScale = 0.8,     // 전체 크기 축소
      dipperRotateDeg = 205, // 현재 각도(시계방향)
      dipperPivotIndex = 4,  // 회전 피벗(1~7)
      dipperOffsetX = 0,
      dipperOffsetY = 0,
      dipperMirrorX = true,
    }) {
      // --- state ---
      const [bgOk, setBgOk] = React.useState(true);
      const [customBgDataUrl, setCustomBgDataUrl] = React.useState("");
      const [active, setActive] = React.useState(null); // {label, desc, href}
      const [aspect, setAspect] = React.useState(canvasAspect);
      const fileInputRef = React.useRef(null);

      // 편집 모드 & 데이터 (localStorage)
      const [editMode, setEditMode] = React.useState(false);
      const [items, setItems] = React.useState(works);

      // 슬라이드 쇼 모달 상태
      const [deckOpen, setDeckOpen] = React.useState(false);
      const [deckNodeIndex, setDeckNodeIndex] = React.useState(0);
      const [deckSlideIndex, setDeckSlideIndex] = React.useState(0);

      // 저장된 배경/작품 로드
      React.useEffect(() => {
        try {
          const savedBg = typeof window !== 'undefined' ? window.localStorage.getItem('dipper:bg') : null;
          if (savedBg) setCustomBgDataUrl(savedBg);
        } catch (e) { console.error('[BigDipper] load bg failed', e); }
        try {
          const savedWorks = typeof window !== 'undefined' ? window.localStorage.getItem('dipper:works') : null;
          if (savedWorks) {
            const parsed = JSON.parse(savedWorks);
            if (Array.isArray(parsed) && parsed.length === 7) setItems(parsed);
          }
        } catch (e) { console.error('[BigDipper] load works failed', e); }
      }, []);

      // 변경 시 자동 저장
      React.useEffect(() => {
        try { window.localStorage.setItem('dipper:works', JSON.stringify(items)); } catch {}
      }, [items]);

      const bgHref = customBgDataUrl && typeof customBgDataUrl === 'string' && customBgDataUrl.length > 0
        ? customBgDataUrl
        : backgroundImageUrl;

      // 제목
      React.useEffect(() => { if (typeof document !== 'undefined') document.title = title; }, [title]);

      // 비율 파싱
      const aspectScale = React.useMemo(() => {
        const m = String(aspect).split('/');
        const w = Math.max(1, parseFloat(m[0] || '16'));
        const h = Math.max(1, parseFloat(m[1] || '9'));
        return { w, h, k: w / h };
      }, [aspect]);

      // 좌표 파이프라인
      const nodesBase = React.useMemo(() => mergeWorksWithLayout(items), [items]);
      const nodesScaled = React.useMemo(
        () => nodesBase.map(n => ({ ...n, x: n.x * aspectScale.k })),
        [nodesBase, aspectScale.k]
      );
      const nodesAdjusted = React.useMemo(() => {
        const cx = (100 * aspectScale.k) / 2;
        const s = Math.max(0.5, Math.min(1, dipperScaleX));
        return nodesScaled.map(n => ({ ...n, x: cx + (n.x - cx) * s }));
      }, [nodesScaled, aspectScale.k, dipperScaleX]);
      const nodesSized = React.useMemo(() => {
        const cx = (100 * aspectScale.k) / 2;
        const cy = 50;
        const s = Math.max(0.6, Math.min(1.2, dipperScale));
        return nodesAdjusted.map(n => ({
          ...n,
          x: cx + (n.x - cx) * s,
          y: cy + (n.y - cy) * s,
        }));
      }, [nodesAdjusted, aspectScale.k, dipperScale]);
      const nodesFinal = React.useMemo(() => {
        // 피벗 회전
        const cx = (100 * aspectScale.k) / 2;
        const cy = 50;
        const pivotIdx = Math.max(1, Math.min(7, dipperPivotIndex)) - 1;
        const pivot = nodesSized[pivotIdx] || { x: cx, y: cy };
        const rad = (Math.PI / 180) * (dipperRotateDeg || 0);
        const cos = Math.cos(rad); const sin = Math.sin(rad);
        return nodesSized.map(n => {
          const dx = n.x - pivot.x, dy = n.y - pivot.y;
          return {
            ...n,
            x: pivot.x + dx * cos - dy * sin + dipperOffsetX,
            y: pivot.y + dx * sin + dy * cos + dipperOffsetY,
          };
        });
      }, [nodesSized, aspectScale.k, dipperRotateDeg, dipperOffsetX, dipperOffsetY, dipperPivotIndex]);
      const nodesScreen = React.useMemo(() => {
        if (!dipperMirrorX) return nodesFinal;
        const cx = (100 * aspectScale.k) / 2;
        return nodesFinal.map(n => ({ ...n, x: cx * 2 - n.x }));
      }, [nodesFinal, dipperMirrorX, aspectScale.k]);

      const polylinePoints = React.useMemo(
        () => nodesScreen.map(n => `${n.x},${n.y}`).join(' '),
        [nodesScreen]
      );

      // 연결선 스타일
      const LINK_STROKE_WIDTH = 0.35;
      const LINK_STROKE_OPACITY = 0.35;
      const LINK_HALO_WIDTH = 0.55;
      const LINK_HALO_OPACITY = 0.18;

      // ────────────────────────────────────────────────────────────────────────────
      // 슬라이드 쇼 동작
      const openDeckIfAny = (nodeIndex) => {
        const d = items[nodeIndex]?.deck || [];
        if (d.length > 0) {
          setDeckNodeIndex(nodeIndex);
          setDeckSlideIndex(0);
          setDeckOpen(true);
          return true;
        }
        return false;
      };
      const closeDeck = () => setDeckOpen(false);
      const nextSlide = () => setDeckSlideIndex(s => Math.min((items[deckNodeIndex]?.deck?.length || 1) - 1, s + 1));
      const prevSlide = () => setDeckSlideIndex(s => Math.max(0, s - 1));

      // 키보드: 좌우 이동
      React.useEffect(() => {
        if (!deckOpen) return;
        const onKey = (e) => {
          if (e.key === 'ArrowRight') nextSlide();
          if (e.key === 'ArrowLeft') prevSlide();
          if (e.key === 'Escape') closeDeck();
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [deckOpen]);

      // ────────────────────────────────────────────────────────────────────────────
      // self-tests (개발 모드 전용)
      React.useEffect(() => {
        if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production') return;
        try {
          const assert = (c, m) => { if (!c) throw new Error(m); };
          assert(Array.isArray(starLayout) && starLayout.length === 7, 'starLayout length');
          const merged = mergeWorksWithLayout(defaultWorks); assert(merged.length === 7, 'merge 7');
          assert(typeof polylinePoints === 'string' && polylinePoints.split(' ').length === 7, '7 points polyline');
          const vbw = 100 * aspectScale.k; assert(Number.isFinite(vbw), 'viewBox width finite');
          // 데이터 구조 테스트
          assert(Array.isArray(items) && items.length === 7, 'items length 7');
          items.forEach((it, i) => {
            assert(typeof it.label === 'string', `label string at ${i}`);
            assert(typeof it.href === 'string', `href string at ${i}`);
            assert(Array.isArray(it.deck), `deck array at ${i}`);
          });
          console.info('[BigDipper] self-tests passed');
        } catch (e) {
          console.warn('[BigDipper] self-tests failed:', e);
        }
      }, [polylinePoints, aspectScale.k, items]);

      // ────────────────────────────────────────────────────────────────────────────
      return (
        <main className="relative min-h-screen w-full bg-black text-white overflow-hidden">
          {/* 배경 그라데이션 */}
          <div aria-hidden className="pointer-events-none absolute inset-0 opacity-80" style={{ background: 'radial-gradient(circle at 50% 50%, #000010 0%, #000000 80%)' }} />

          {/* 헤더 */}
          <header className="relative z-10 mx-auto max-w-5xl px-6 pt-10 pb-6 flex items-center justify-between">
            <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">{title}</h1>
            <div className="flex items-center gap-2">
              <button onClick={() => setEditMode(v => !v)} className={`text-xs md:text-sm px-3 py-1.5 rounded-xl border ${editMode ? 'bg-teal-500/20 border-teal-400/40' : 'bg-white/10 hover:bg-white/15 border-white/15'}`}>{editMode ? '편집 모드: ON' : '편집 모드'}</button>
              <button onClick={() => fileInputRef.current?.click()} className="text-xs md:text-sm px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15">배경 이미지 선택</button>
              <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={(e) => {
                const f = e.target.files?.[0]; if (!f) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                  const dataUrl = String(ev.target?.result || '');
                  setCustomBgDataUrl(dataUrl); setBgOk(true);
                  try { window.localStorage.setItem('dipper:bg', dataUrl); } catch (err) { console.error('[BigDipper] save bg failed', err); }
                };
                reader.readAsDataURL(f);
              }} />
              {/* 내보내기 */}
              <button
                onClick={() => {
                  try {
                    const data = JSON.stringify(items, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'dipper-works.json'; a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 500);
                  } catch (e) { console.error('export failed', e); }
                }}
                className="text-xs md:text-sm px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15"
              >내보내기</button>
              {/* 가져오기 */}
              <label className="text-xs md:text-sm px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15 cursor-pointer">
                가져오기
                <input type="file" accept="application/json" className="hidden" onChange={async (e) => {
                  const f = e.target.files?.[0]; if (!f) return;
                  try {
                    const text = await f.text();
                    const json = JSON.parse(text);
                    if (Array.isArray(json) && json.length === 7) setItems(json);
                    else alert('형식이 올바르지 않습니다. 7개 항목 배열이어야 해요.');
                  } catch (err) { console.error('import failed', err); }
                }} />
              </label>
            </div>
          </header>

          {/* 안내/초기화 */}
          <div className="relative z-10 mx-auto max-w-5xl px-6 -mt-3 pb-2 flex gap-3 text-xs md:text-sm text-white/70">
            <button onClick={() => { try { window.localStorage.removeItem('dipper:bg'); setCustomBgDataUrl(''); setBgOk(true);} catch (e) { console.error('[BigDipper] clear bg failed', e);} }} className="px-3 py-1.5 rounded-xl bg-white/5 hover:bg-white/10 border border-white/15">기본 배경 초기화</button>
            <span className="opacity-70">배경/콘텐츠는 브라우저에 저장되어 다음 방문에도 유지됩니다.</span>
          </div>

          {/* 편집 패널 */}
          {editMode && (
            <section className="relative z-10 mx-auto max-w-5xl w-full px-4 pb-4">
              <div className="grid md:grid-cols-2 gap-4">
                {items.map((it, i) => (
                  <div key={i} className="rounded-xl border border-white/15 bg-white/5 p-3">
                    <div className="text-xs text-white/70 mb-2">노드 {i+1} – {it.key}</div>
                    <div className="grid grid-cols-3 gap-2">
                      <label className="col-span-1 text-xs text-white/70">제목</label>
                      <input className="col-span-2 bg-black/30 border border-white/15 rounded-md px-2 py-1 text-sm" value={it.label} onChange={(e)=>{
                        const v = e.target.value; setItems(prev => prev.map((p,j)=> j===i?{...p,label:v}:p));
                      }} />
                      <label className="col-span-1 text-xs text-white/70">설명</label>
                      <input className="col-span-2 bg-black/30 border border-white/15 rounded-md px-2 py-1 text-sm" value={it.desc} onChange={(e)=>{
                        const v = e.target.value; setItems(prev => prev.map((p,j)=> j===i?{...p,desc:v}:p));
                      }} />
                      <label className="col-span-1 text-xs text-white/70">링크</label>
                      <input className="col-span-2 bg-black/30 border border-white/15 rounded-md px-2 py-1 text-sm" value={it.href} onChange={(e)=>{
                        const v = e.target.value; setItems(prev => prev.map((p,j)=> j===i?{...p,href:v}:p));
                      }} />
                    </div>
                    {/* 슬라이드 에디터 */}
                    <div className="mt-3">
                      <div className="flex items-center justify-between mb-2">
                        <div className="text-xs text-white/70">슬라이드 ({it.deck?.length||0})</div>
                        <div className="flex gap-2">
                          <label className="text-xs px-2 py-1 rounded bg-white/10 border border-white/15 cursor-pointer">이미지 추가
                            <input type="file" accept="image/*" className="hidden" onChange={(e)=>{
                              const f = e.target.files?.[0]; if(!f) return;
                              const reader = new FileReader();
                              reader.onload = (ev)=>{
                                const src = String(ev.target?.result || '');
                                setItems(prev => prev.map((p,j)=> j===i?{...p, deck:[...(p.deck||[]), {type:'image', src, caption:''}]}:p));
                              };
                              reader.readAsDataURL(f);
                            }} />
                          </label>
                          <button className="text-xs px-2 py-1 rounded bg-white/10 border border-white/15" onClick={()=>{
                            // 이미지+텍스트(좌)
                            setItems(prev => prev.map((p,j)=> j===i?{...p, deck:[...(p.deck||[]), {type:'imageText', layout:'left', src:'', title:'제목', body:'설명', caption:''}]}:p));
                          }}>이미지+텍스트(좌)</button>
                          <button className="text-xs px-2 py-1 rounded bg-white/10 border border-white/15" onClick={()=>{
                            // 이미지+텍스트(우)
                            setItems(prev => prev.map((p,j)=> j===i?{...p, deck:[...(p.deck||[]), {type:'imageText', layout:'right', src:'', title:'제목', body:'설명', caption:''}]}:p));
                          }}>이미지+텍스트(우)</button>
                          <button className="text-xs px-2 py-1 rounded bg-white/10 border border-white/15" onClick={()=>{
                            // 텍스트 전용
                            setItems(prev => prev.map((p,j)=> j===i?{...p, deck:[...(p.deck||[]), {type:'textOnly', title:'제목', body:'문단 내용을 입력하세요.'}]}:p));
                          }}>텍스트 슬라이드</button>
                        </div>
                      </div>
                      <div className="grid md:grid-cols-3 gap-2">
                        {(it.deck||[]).map((s, k) => (
                          <div key={k} className="bg-black/30 border border-white/15 rounded-md p-2">
                            {/* 유형별 필드 */}
                            <div className="text-[10px] uppercase tracking-wide text-white/50 mb-1">{s.type||'image'}</div>
                            {s.type === 'image' && (
                              <>
                                <img src={s.src||''} alt="slide" className="w-full h-24 object-cover rounded" />
                                <label className="mt-1 block text-xs text-white/70">캡션</label>
                                <input className="w-full bg-black/40 border border-white/15 rounded px-2 py-1 text-xs" value={s.caption||''} onChange={(e)=>{
                                  const v = e.target.value;
                                  setItems(prev => prev.map((p,j)=> {
                                    if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k] = {...nd[k], caption:v}; return {...p, deck: nd};
                                  }));
                                }} />
                                <label className="mt-1 block text-xs text-white/70 cursor-pointer">이미지 교체
                                  <input type="file" accept="image/*" className="hidden" onChange={(e)=>{
                                    const f = e.target.files?.[0]; if(!f) return; const reader=new FileReader();
                                    reader.onload = (ev)=>{
                                      const src = String(ev.target?.result || '');
                                      setItems(prev => prev.map((p,j)=> { if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k] = {...nd[k], src}; return {...p, deck: nd}; }));
                                    };
                                    reader.readAsDataURL(f);
                                  }} />
                                </label>
                              </>
                            )}
                            {s.type === 'imageText' && (
                              <>
                                <label className="block text-xs text-white/70">제목</label>
                                <input className="w-full bg-black/40 border border-white/15 rounded px-2 py-1 text-xs" value={s.title||''} onChange={(e)=>{
                                  const v=e.target.value; setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], title:v}; return {...p, deck: nd}; }));
                                }} />
                                <label className="mt-1 block text-xs text-white/70">본문</label>
                                <textarea rows={3} className="w-full bg-black/40 border border-white/15 rounded px-2 py-1 text-xs" value={s.body||''} onChange={(e)=>{
                                  const v=e.target.value; setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], body:v}; return {...p, deck: nd}; }));
                                }} />
                                <div className="flex items-center gap-2 mt-1">
                                  <span className="text-xs text-white/70">레이아웃</span>
                                  {['left','right','overlay'].map(opt => (
                                    <button key={opt} className={`text-[11px] px-2 py-0.5 rounded border ${s.layout===opt?'bg-white/20 border-white/40':'bg-white/10 border-white/20'}`} onClick={()=>{
                                      setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], layout:opt}; return {...p, deck: nd}; }));
                                    }}>{opt}</button>
                                  ))}
                                </div>
                                <label className="mt-1 block text-xs text-white/70 cursor-pointer">이미지 선택/교체
                                  <input type="file" accept="image/*" className="hidden" onChange={(e)=>{
                                    const f = e.target.files?.[0]; if(!f) return; const reader=new FileReader();
                                    reader.onload=(ev)=>{
                                      const src=String(ev.target?.result||'');
                                      setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], src}; return {...p, deck: nd}; }));
                                    };
                                    reader.readAsDataURL(f);
                                  }} />
                                </label>
                              </>
                            )}
                            {s.type === 'textOnly' && (
                              <>
                                <label className="block text-xs text-white/70">제목</label>
                                <input className="w-full bg-black/40 border border-white/15 rounded px-2 py-1 text-xs" value={s.title||''} onChange={(e)=>{
                                  const v=e.target.value; setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], title:v}; return {...p, deck: nd}; }));
                                }} />
                                <label className="mt-1 block text-xs text-white/70">본문</label>
                                <textarea rows={4} className="w-full bg-black/40 border border-white/15 rounded px-2 py-1 text-xs" value={s.body||''} onChange={(e)=>{
                                  const v=e.target.value; setItems(prev=>prev.map((p,j)=>{ if(j!==i) return p; const nd=[...(p.deck||[])]; nd[k]={...nd[k], body:v}; return {...p, deck: nd}; }));
                                }} />
                              </>
                            )}
                            <button className="mt-2 w-full text-xs px-2 py-1 rounded bg-red-500/20 border border-red-400/30" onClick={()=>{
                              setItems(prev => prev.map((p,j)=> {
                                if(j!==i) return p; const nd = [...(p.deck||[])]; nd.splice(k,1); return {...p, deck: nd};
                              }));
                            }}>삭제</button>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </section>
          )}

          {/* 캔버스 */}
          <section className="relative z-10 mx-auto max-w-5xl w-full px-4 pb-16">
            <div className="relative w-full rounded-2xl border border-white/10 shadow-2xl overflow-hidden" style={{ aspectRatio: aspect }}>
              <svg viewBox={`0 0 ${100 * aspectScale.k} 100`} preserveAspectRatio="xMidYMid meet" className="h-full w-full">
                <defs>
                  <linearGradient id="blueCast" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stopColor="#0e1a3a" />
                    <stop offset="100%" stopColor="#0a0f23" />
                  </linearGradient>
                  <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="0.8" result="coloredBlur" />
                    <feMerge>
                      <feMergeNode in="coloredBlur" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>
                  <filter id="tinyGlow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="0.25" result="b" />
                    <feMerge>
                      <feMergeNode in="b" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>
                </defs>

                {/* 배경 */}
                {backgroundMode === 'image' && bgHref && bgOk ? (
                  <image href={bgHref} x={0} y={0} width={100 * aspectScale.k} height={100} preserveAspectRatio="xMidYMid slice" crossOrigin="anonymous" onError={() => setBgOk(false)} />
                ) : (
                  <rect x="0" y="0" width={100 * aspectScale.k} height="100" fill="#0b1024" />
                )}
                <rect x="0" y="0" width={100 * aspectScale.k} height="100" fill="url(#blueCast)" opacity="0.25" />

                {/* 절차적 배경 별 (옵션) */}
                {backgroundMode !== 'image' && showOverlayStars && (
                  Array.from({ length: 80 }).map((_, i) => {
                    const seed = Math.sin((i + 1) * 9876.543) * 10000;
                    const fx = seed - Math.floor(seed);
                    const fy = Math.sin(seed * 1.7) - Math.floor(Math.sin(seed * 1.7));
                    const x = Math.abs(fx) * 100; const y = Math.abs(fy) * 100;
                    const r = 0.08 + ((i % 7) / 7) * 0.28; // 0.08~0.36
                    const bluish = 205 + (i % 24); const alpha = 0.2 + ((i % 11) / 11) * 0.28;
                    return (
                      <g key={i} transform={`translate(${x} ${y})`} opacity={0.9}>
                        <circle r={r + 0.08} fill="rgba(255,255,255,0.18)" filter="url(#tinyGlow)" />
                        <circle r={r} fill={`rgb(${bluish}, ${bluish + 18}, 255)`} opacity={alpha} />
                      </g>
                    );
                  })
                )}

                {/* 연결선 (헤일로 + 본선) */}
                <polyline points={polylinePoints} fill="none" stroke={`rgba(255,255,255,${LINK_HALO_OPACITY})`} strokeWidth={LINK_HALO_WIDTH} strokeLinejoin="round" strokeLinecap="round" vectorEffect="non-scaling-stroke" filter="url(#glow)" />
                <polyline points={polylinePoints} fill="none" stroke={`rgba(255,255,255,${LINK_STROKE_OPACITY})`} strokeWidth={LINK_STROKE_WIDTH} strokeLinejoin="round" strokeLinecap="round" vectorEffect="non-scaling-stroke" filter="url(#glow)" />

                {/* 별들 */}
                {nodesScreen.map((n, idx) => (
                  <Node key={n.id ?? idx} data={n} onHover={setActive} onClickNode={() => {
                    const handled = openDeckIfAny(idx);
                    if (!handled) {
                      try { window.open(items[idx]?.href || '#', '_blank', 'noreferrer'); } catch {}
                    }
                  }} />
                ))}
              </svg>

              {/* 정보 패널 */}
              <div className="pointer-events-none absolute right-3 bottom-3 md:right-4 md:bottom-4">
                <div className={`transition-all duration-200 backdrop-blur-md rounded-xl border border-white/15 shadow-lg ${active ? 'bg-black/35 opacity-100 translate-y-0' : 'bg-black/20 opacity-0 translate-y-2'} max-w-[70vw] md:max-w-sm`} style={{ pointerEvents: 'none' }}>
                  <div className="px-4 py-3">
                    <div className="text-xs uppercase tracking-wider text-white/60">Project</div>
                    <div className="mt-0.5 text-base md:text-lg font-medium">{active?.label ?? '노드에 마우스를 올려보세요'}</div>
                    <div className="mt-1 text-xs md:text-sm text-white/75 leading-snug line-clamp-3">{active?.desc ?? '우측하단에 프로젝트 이름과 설명이 표시됩니다.'}</div>
                    {active?.href ? (<div className="mt-2 text-xs text-white/70">링크: <span className="underline underline-offset-4">{active.href}</span></div>) : null}
                  </div>
                </div>
              </div>
            </div>
          </section>

          {/* 모달 슬라이드 쇼 */}
          {deckOpen && (
            <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center">
              <div className="relative w-[92vw] max-w-5xl rounded-xl overflow-hidden border border-white/15 bg-black">
                <div className="flex items-center justify-between px-4 py-2 border-b border-white/10">
                  <div className="text-sm text-white/80">{items[deckNodeIndex]?.label} – {deckSlideIndex+1}/{items[deckNodeIndex]?.deck?.length || 1}</div>
                  <button className="text-sm px-2 py-1 bg-white/10 rounded border border-white/20" onClick={closeDeck}>닫기</button>
                </div>
                <div className="p-4 bg-black">
                  {(() => {
                    const s = items[deckNodeIndex]?.deck?.[deckSlideIndex];
                    if (!s) return <div className="text-center text-white/70 py-16">슬라이드가 없습니다.</div>;
                    if (s.type === 'textOnly') {
                      return (
                        <div className="grid gap-3">
                          <h2 className="text-xl md:text-2xl font-semibold">{s.title||''}</h2>
                          <p className="text-white/80 leading-relaxed whitespace-pre-wrap">{s.body||''}</p>
                        </div>
                      );
                    }
                    if (s.type === 'imageText') {
                      if (s.layout === 'overlay') {
                        return (
                          <figure className="relative">
                            {s.src ? (<img src={s.src} alt="slide" className="w-full max-h-[70vh] object-contain md:object-cover rounded" />) : (<div className="w-full h-[40vh] bg-white/5 rounded grid place-items-center text-white/40">이미지 없음</div>)}
                            <figcaption className="absolute inset-x-0 bottom-0 p-4 md:p-6 bg-gradient-to-t from-black/70 to-black/10">
                              <div className="text-lg md:text-xl font-semibold">{s.title||''}</div>
                              <div className="text-white/80 text-sm md:text-base whitespace-pre-wrap">{s.body||''}</div>
                            </figcaption>
                          </figure>
                        );
                      }
                      // 좌/우 두단 레이아웃
                      const imgFirst = s.layout === 'left';
                      return (
                        <div className="grid md:grid-cols-2 gap-4 items-center">
                          {imgFirst && (
                            s.src ? (<img src={s.src} alt="slide" className="w-full max-h-[60vh] object-contain rounded" />) : (<div className="w-full h-[30vh] bg-white/5 rounded grid place-items-center text-white/40">이미지 없음</div>)
                          )}
                          <div className="grid gap-2">
                            <h2 className="text-xl md:text-2xl font-semibold">{s.title||''}</h2>
                            <p className="text-white/80 leading-relaxed whitespace-pre-wrap">{s.body||''}</p>
                            {s.caption ? (<div className="text-white/60 text-xs">{s.caption}</div>) : null}
                          </div>
                          {!imgFirst && (
                            s.src ? (<img src={s.src} alt="slide" className="w-full max-h-[60vh] object-contain rounded" />) : (<div className="w-full h-[30vh] bg-white/5 rounded grid place-items-center text-white/40">이미지 없음</div>)
                          )}
                        </div>
                      );
                    }
                    // 기본: image
                    return (
                      <figure className="grid gap-2">
                        {s.src ? (<img src={s.src} alt="slide" className="w-full max-h-[70vh] object-contain rounded" />) : (<div className="w-full h-[40vh] bg-white/5 rounded grid place-items-center text-white/40">이미지 없음</div>)}
                        {s.caption ? (<figcaption className="text-center text-white/70 text-sm">{s.caption}</figcaption>) : null}
                      </figure>
                    );
                  })()}
                </div>
                <div className="flex items-center justify-between px-4 py-2 border-t border-white/10">
                  <button className="px-3 py-1 rounded bg-white/10 border border-white/20" onClick={prevSlide}>이전</button>
                  <div className="text-xs text-white/50">← → 키로 이동 • Esc 닫기</div>
                  <button className="px-3 py-1 rounded bg-white/10 border border-white/20" onClick={nextSlide}>다음</button>
                </div>
              </div>
            </div>
          )}
        </main>
      );
    }

    function Node({ data, onHover, onClickNode }) {
      const { x, y, label } = data ?? {};
      const rOuter = 1.15; // 반짝 오라
      const rCore = 0.48;  // 코어 점

      const handleEnter = () => onHover?.({ label: String(data.label || ''), desc: String(data.desc || ''), href: String(data.href || '') });
      const handleLeave = () => onHover?.(null);

      return (
        <g transform={`translate(${x} ${y})`}>
          {/* a 대신 클릭 이벤트로 제어: deck이 있으면 모달, 없으면 window.open */}
          <g role="button" tabIndex={0} onClick={() => onClickNode?.()} onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') onClickNode?.(); }} onMouseEnter={handleEnter} onMouseLeave={handleLeave} onFocus={handleEnter} onBlur={handleLeave}>
            <title>{label}</title>
            <circle r={4.8} fill="transparent" />
            <circle r={rOuter} fill="rgba(255,255,255,0.20)">
              <animate attributeName="r" values={`${rOuter};${rOuter + 0.8};${rOuter}`} dur="2.8s" repeatCount="indefinite" />
              <animate attributeName="opacity" values="0.20;0.12;0.20" dur="2.8s" repeatCount="indefinite" />
            </circle>
            <circle r={rCore} fill="#ffffff" filter="url(#glow)">
              <animate attributeName="r" values={`${rCore};${rCore + 0.3};${rCore}`} dur="1.8s" repeatCount="indefinite" />
            </circle>
          </g>
        </g>
      );
    }

    // 렌더링
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<BigDipperPortfolio />);
  </script>
</body>
</html>
